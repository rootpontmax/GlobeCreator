#include "Types.h"

#include <cmath>

////////////////////////////////////////////////////////////////////////////////////////////////////
SVert::SVert() :
    x( 0.0f ),
    y( 0.0f ),
    z( 0.0f )
{}
////////////////////////////////////////////////////////////////////////////////////////////////////
SVert::SVert( const float _x, const float _y, const float _z ) :
    x( _x ),
    y( _y ),
    z( _z )
{}
////////////////////////////////////////////////////////////////////////////////////////////////////
SVert& SVert::operator+( const SVert& rhs )
{
    x += rhs.x;
    y += rhs.y;
    z += rhs.z;
    return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
SVert& SVert::operator*( float coef )
{
    x *= coef;
    y *= coef;
    z *= coef;
    return *this;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
SVert SVert::GetNormalazed() const
{
    SVert res( x, y, z );
    res.Normalize();
    return res;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
void SVert::Normalize()
{
    const float length = sqrt( x * x + y * y + z * z );
    x /= length;
    y /= length;
    z /= length;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
SEdge::SEdge() :
    idA( INVALID_ID ),
    idB( INVALID_ID ),
    faceID{ INVALID_ID, INVALID_ID }
{}
////////////////////////////////////////////////////////////////////////////////////////////////////    
SEdge::SEdge( const int _idA, const int _idB ) :
    faceID{ INVALID_ID, INVALID_ID }
{
    const bool bIsABigger = ( _idA > _idB ); 
    idA = bIsABigger ? _idB : _idA; 
    idB = bIsABigger ? _idA : _idB;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
void SEdge::RegisterFace( const int id )
{
    for( int i = 0; i < 2; ++i )
        if( INVALID_ID == faceID[i] )
        {
            faceID[i] = id;
            return;
        }
    abort();
}
////////////////////////////////////////////////////////////////////////////////////////////////////
bool operator<( const SEdge& lhs, const SEdge& rhs )
{
    if( lhs.idA < rhs.idA )
        return true;
    else if( lhs.idA == rhs.idA )
        return ( lhs.idB < rhs.idB );
    else
        return false;
}
/*
bool SEdge::operator<( const SEdge& rhs ) const
{
    if( idA < rhs.idA )
        return true;
    else if( idA == rhs.idA )
        return ( idB < rhs.idB );
    else
        return false;
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////
/*
////////////////////////////////////////////////////////////////////////////////////////////////////
bool SEdge::operator==( const SEdge& rhs ) const
{
    return ( idA == rhs.idA && idB == rhs.idB );
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////
SFace::SFace( const int _regionID, const int idA, const int idB, const int idC ) :
    regionID( _regionID ),
    pointID{ idA, idB, idC }
{}
////////////////////////////////////////////////////////////////////////////////////////////////////
SIcosahedron::SIcosahedron() :
    level( 0 )
{}
////////////////////////////////////////////////////////////////////////////////////////////////////
SVert operator+( const SVert& lhs, const SVert& rhs )
{
    SVert res;
    res.x = lhs.x + rhs.x;
    res.y = lhs.y + rhs.y;
    res.z = lhs.z + rhs.z;
    return res;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
